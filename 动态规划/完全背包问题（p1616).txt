仿照01背包问题只需要把动态转移方程改为
d[i][j]=max(d[i-1][j],d[i][j-a[i]]+b[i])
d[i-1][j]代表不取第i件物品，另外一个代表取第i件物品，和01背包不同，因为完全背包是无限的物品，所以不需要减1.

当然我们类似于01背包问题可以继续优化空间复杂度，

我们注意到d[i]的值只和d[i-1]的值有关，所以我们可以用d[2][j]两个一维数组来储存

但是其实可以更近一步优化，d[i][j]只与d[i-1][j]和d[i][j-a[i]]有关，如果能保证在推d[i][j]时（也即在第i次主循环中推d[j]时）能够得到d[i-1][j]和d[i][j-a[i]]的值呢？
那么我们就只需要一个d[j]就可以了。
for (int i = 1; i <= n; i++)
  for (int l = 0; l <= W - w[i]; l++)
    f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);
// 由 f[i][l + w[i]] = max(max(f[i - 1][l + w[i]],f[i - 1][l] + w[i]),f[i][l +
// w[i]]); 简化而来



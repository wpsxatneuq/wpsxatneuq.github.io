floyd算法是一种基于动态规划的算法，用一个数组f[k][x][y]表示只允许经过结点1到k(也就是说，在子图 中的路径，注意,x与y不一定在这个子图中），结点x到结点y的最短路长度
显然，fnxy就是我们要求的x到y的最短路径。
初始化，f0xy=mapxy
动态转移方程：显然结点k我们只有走和不走两种情况，因此可以得出动态转移方程
fkxy=min（fk-1xy，fk-1xk+fk-1ky）//第一个对应不走第k个点，第二个对应走
可以证明第一维是可以去掉的，因此，我们可以得到如下的核心代码
for (k = 1; k <= n; k++) 
{
  for (x = 1; x <= n; x++) 
  {
    for (y = 1; y <= n; y++) 
    {
      f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
    }
  }
}


应用

1.给一个正权无向图，找一个最小权值和的环。
先考虑一个环是如何组成的，考虑环上编号最大的结点k，那么这个环一定是由fxy和mapux，mapuy组成的（x，y，k互不相同）
在 Floyd 的过程中枚举k，计算这个和的最小值即可。

2.判断图的联通性
如果两点联通就初始化为1，然后利用或运算，进行Floyd算法即可
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                dis[i][j] = dis[i][j] || (dis[i][k] && dis[k][j]);
}
除此之外还有可以用bfs，dfs，并查集来判断
